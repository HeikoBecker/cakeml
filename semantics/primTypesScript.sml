(*Generated by Lem from primTypes.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory libTheory astTheory namespaceTheory ffiTheory semanticPrimitivesTheory evaluateTheory typeSystemTheory;

val _ = numLib.prefer_num();



val _ = new_theory "primTypes"

(*
  Definition of the primitive types that are in scope before any CakeML program
  starts. Some of them are generated by running an initial program.
*)
(*open import Pervasives*)
(*open import Ast*)
(*open import SemanticPrimitives*)
(*open import Ffi*)
(*open import Namespace*)
(*open import Lib*)
(*open import Evaluate*)

(* The ordering in the following is important. The stamps generated from the
   exceptions and types must match those in semanticPrimitives *)
(*val prim_types_program : list dec*)
val _ = Define `
 ((prim_types_program:(dec)list)=
   ([Dexn unknown_loc (Strlit "Bind") [];
   Dexn unknown_loc (Strlit "Chr") [];
   Dexn unknown_loc (Strlit "Div") [];
   Dexn unknown_loc (Strlit "Subscript") [];
   Dtype unknown_loc [([], (Strlit "bool"), [(Strlit "False", []); (Strlit "True", [])])];
   Dtype unknown_loc [([Strlit "'a"], (Strlit "list"),
                       [(Strlit "[]", []); (Strlit "::", [Atvar (Strlit "'a"); Atapp [Atvar (Strlit "'a")] (Short (Strlit "list"))]) ])] ]))`;


(*val add_to_sem_env :
  forall 'ffi. Eq 'ffi => (state 'ffi * sem_env v) -> list dec -> maybe (state 'ffi * sem_env v)*)
val _ = Define `
 ((add_to_sem_env:'ffi state#(v)sem_env ->(dec)list ->('ffi state#(v)sem_env)option) (st, env) prog=
   ((case evaluate_decs st env prog of
    (st', Rval env') => SOME (st', extend_dec_env env' env)
  | _ => NONE
  )))`;


(*val prim_sem_env : forall 'ffi. Eq 'ffi => ffi_state 'ffi -> maybe (state 'ffi * sem_env v)*)
val _ = Define `
 ((prim_sem_env:'ffi ffi_state ->('ffi state#(v)sem_env)option) ffi=
   (add_to_sem_env
    (<| clock :=(( 0 : num)); ffi := ffi; refs := ([]); next_type_stamp :=(( 0 : num)); next_exn_stamp :=(( 0 : num)) |>,
     <| v := nsEmpty; c := nsEmpty |>)
        prim_types_program))`;


(*open import TypeSystem*)

val _ = Define `
 ((prim_tenv:type_env)=
     (<| c := (alist_to_ns (REVERSE
          [(Strlit "Bind", ([],[],Texn_num));
           (Strlit "Chr", ([],[],Texn_num));
           (Strlit "Div", ([],[],Texn_num));
           (Strlit "Subscript", ([],[],Texn_num));
           (Strlit "False", ([],[], Tbool_num));
           (Strlit "True", ([],[], Tbool_num));
           (Strlit "[]", ([Strlit "'a"],[],Tlist_num));
           (Strlit "::", ([Strlit "'a"],[Tvar (Strlit "'a"); Tlist (Tvar (Strlit "'a"))], Tlist_num))]));
       v := nsEmpty;
       t := (alist_to_ns (REVERSE
          [
          (Strlit "array",([Strlit "'a"],Tapp [Tvar (Strlit "'a")] Tarray_num));
          (Strlit "bool",([],Tapp [] Tbool_num));
          (Strlit "char",([],Tapp [] Tchar_num));
          (Strlit "exn",([],Tapp [] Texn_num));
          (* Tfn is ->, specially handled *)
          (Strlit "int",([],Tapp [] Tint_num));
          (Strlit "list",([Strlit "'a"],Tapp [Tvar (Strlit "'a")] Tlist_num));
          (Strlit "ref",([Strlit "'a"],Tapp [Tvar (Strlit "'a")] Tref_num));
          (Strlit "string",([],Tapp [] Tstring_num));
          (Strlit "unit",([],Tapp [] Ttup_num));
          (* pairs are specially handled *)
          (Strlit "vector",([Strlit "'a"],Tapp [Tvar (Strlit "'a")] Tvector_num));
          (Strlit "word64",([],Tapp [] Tword64_num));
          (Strlit "word8",([],Tapp [] Tword8_num));
          (Strlit "word8array",([],Tapp [] Tword8array_num))]
          ))|>))`;


val _ = Define `
 ((prim_type_ids:(num)set)=  (LIST_TO_SET (Tlist_num :: (Tbool_num :: prim_type_nums))))`;

val _ = export_theory()

